# 数据模型与查询语言

> 语言的边界就是世界的边界。
> 
> ——路德维希・维特根斯坦，《逻辑哲学论》（1922）

## 为什么数据模型如此重要？

数据模型是软件开发中最核心的部分之一，它不仅决定了代码如何编写，更深刻影响着我们**思考问题的方式**。大多数应用程序都是通过层层叠加的数据模型构建的：每一层都试图用更低层次的模型来“表示”更高层次的概念。

例如：
- 应用开发者观察现实世界（人员、组织、商品、行为等），并用对象或数据结构建模；
- 存储时，这些结构被转换为通用格式，如 JSON、XML、关系表或图结构；
- 数据库工程师再决定如何将这些结构编码为磁盘或内存中的字节；
- 硬件工程师最终用电流、光脉冲等方式表示这些字节。

每一层都通过提供简洁的抽象隐藏下层复杂性，使不同角色（如数据库工程师和应用开发者）可以高效协作。

## 常见数据模型及其适用场景

实践中广泛使用的数据模型包括：
- **关系模型**（SQL 表）
- **文档模型**（JSON/XML）
- **图模型**（顶点与边）
- **事件溯源模型**（不可变日志）
- **数据框与矩阵**（科学计算/机器学习）

每种模型在表达特定类型的数据和查询时各有优劣。本章将对比它们的设计理念、查询语言及适用场景，帮助你做出合理的技术选型。

### 声明式 vs 命令式查询语言

许多现代查询语言（如 SQL、Cypher、SPARQL、Datalog）是**声明式**的：你只需描述“想要什么”，而无需指定“如何获取”。数据库系统会自动选择最优执行路径（如索引、连接算法、并行策略等）。

相比之下，传统编程语言通常是**命令式**的——你需要明确告诉计算机每一步操作。声明式语言的优势在于：
- 更简洁，减少样板代码；
- 隐藏实现细节，便于性能优化；
- 支持自动并行化，提升扩展性。

---

## 关系模型 vs 文档模型

### 关系模型：经典而强大

由 Edgar Codd 于 1970 年提出，数据以“关系”（即表）形式组织，每张表是“元组”（行）的无序集合。尽管最初被质疑效率，但到 1980 年代中期，关系数据库（RDBMS）和 SQL 已成为主流。

关系模型至今仍主导商业分析、财务系统等领域，并不断演进——现代 SQL 已支持 JSON、XML 和图数据类型。

### 文档模型：灵活与局部性

NoSQL 运动推动了文档模型的流行，尤其是以 JSON 为代表的数据结构。文档数据库（如 MongoDB、Couchbase）因其模式灵活性和读取局部性受到欢迎，如今多数关系数据库也已支持 JSON。

#### 对象-关系阻抗不匹配

面向对象语言与关系表之间的“转换鸿沟”常被称为**阻抗不匹配**。ORM（如 Hibernate、ActiveRecord）虽能减少样板代码，但仍存在以下问题：
- 无法完全隐藏模型差异；
- 通常仅适用于 OLTP 场景；
- 复杂查询仍需手写 SQL；
- 易产生 N+1 查询性能问题。

#### 文档模型的优势示例：简历数据

考虑一个 LinkedIn 个人资料，包含用户基本信息、工作经历、教育背景等。关系模型需拆分为多张表并通过外键关联，而 JSON 文档可自然嵌套所有信息：

```json
{
    "user_id": 251,
    "first_name": "Barack",
    "last_name": "Obama",
    "positions": [
        {"job_title": "President", "organization": "United States of America"},
        {"job_title": "US Senator (D-IL)", "organization": "United States Senate"}
    ],
    "education": [
        {"school_name": "Harvard University", "start": 1988, "end": 1991},
        {"school_name": "Columbia University", "start": 1981, "end": 1983}
    ]
}
```

这种结构具有更好的**数据局部性**：一次查询即可获取完整信息，避免多表 JOIN 或多次查询。

### 规范化 vs 反规范化

- **规范化**：通过 ID 引用共享数据（如地区、公司），减少冗余，便于维护一致性；
- **反规范化**：直接内联数据（如字符串），提升读取性能，但增加更新成本。

**权衡原则**：
- OLTP 系统倾向规范化（写快、一致性强）；
- 分析系统倾向反规范化（读快、批量更新）；
- 超大规模系统中，JOIN 成本可能成为瓶颈。

#### 社交网络案例：X（原 Twitter）的时间线

X 的时间线采用“部分反规范化”策略：预计算时间线仅存储帖子 ID，实际内容通过“ID 补全”（hydrating）在读取时动态加载。这样既避免频繁更新冗余数据，又保持显示内容的实时性。

---

## 图数据模型：处理复杂关系

当数据中存在大量**多对多关系**时，图模型比关系模型更自然。图由**顶点**（节点）和**边**（关系）组成，适合建模社交网络、知识图谱、推荐系统等。

### 属性图模型（如 Neo4j）

每个顶点和边可携带属性（键值对），支持灵活的数据建模。例如：

```cypher
CREATE
    (lucy:Person {name:'Lucy'}),
    (idaho:Location {name:'Idaho', type:'state'}),
    (lucy)-[:BORN_IN]->(idaho)
```

### Cypher 查询语言

Cypher 使用直观的箭头语法表达图遍历。例如，查找“从美国移民到欧洲的人”：

```cypher
MATCH
    (person)-[:BORN_IN]->()-[:WITHIN*0..]->(:Location {name:'United States'}),
    (person)-[:LIVES_IN]->()-[:WITHIN*0..]->(:Location {name:'Europe'})
RETURN person.name
```

### SQL 中的图查询

虽然图数据可在关系表中存储，但 SQL 表达递归查询较为繁琐。自 SQL:1999 起支持 `WITH RECURSIVE`，但语法复杂。未来 SQL 标准计划引入 **GQL**（Graph Query Language）以简化图查询。

### 三元组存储与 SPARQL

三元组存储（如 RDF）以 `(主语, 谓语, 宾语)` 形式记录数据，适合语义网和知识图谱。SPARQL 是其标准查询语言，语法与 Cypher 类似：

```sparql
PREFIX : <urn:example:>
SELECT ?personName WHERE {
    ?person :name ?personName.
    ?person :bornIn / :within* / :name "United States".
    ?person :livesIn / :within* / :name "Europe".
}
```

### Datalog：声明式递归查询

Datalog 是一种基于逻辑编程的查询语言，擅长表达复杂递归关系。例如：

```datalog
within_recursive(LocID, PlaceName) :- location(LocID, PlaceName, _).
within_recursive(LocID, PlaceName) :- within(LocID, ViaID), within_recursive(ViaID, PlaceName).

migrated(PName, BornIn, LivingIn) :- 
    person(PersonID, PName),
    born_in(PersonID, BornID),
    within_recursive(BornID, BornIn),
    lives_in(PersonID, LivingID),
    within_recursive(LivingID, LivingIn).

us_to_europe(Person) :- migrated(Person, "United States", "Europe").
```

### GraphQL：为前端优化的查询语言

GraphQL 允许客户端精确请求所需数据，避免过度获取。但它不支持递归查询或任意条件搜索，安全性限制较多。示例：

```graphql
query ChatApp {
    channels {
        name
        recentMessages(latest: 50) {
            timestamp
            content
            sender { fullName imageUrl }
            replyTo { content sender { fullName } }
        }
    }
}
```

---

## 事件溯源与 CQRS

### 核心思想

- **事件溯源**：将每次状态变更记录为不可变事件，形成追加日志；
- **CQRS**（命令查询责任分离）：写操作（命令）与读操作（查询）使用不同模型，读模型从事件日志派生。

### 优势
- 事件清晰表达“业务意图”（如“预订已取消”）；
- 物化视图可重建，便于修复错误或添加新功能；
- 支持多种读优化视图（关系表、文档、图等）；
- 提供天然审计日志。

### 挑战
- 需处理外部依赖（如汇率波动）；
- 个人数据删除（GDPR 合规）较复杂；
- 重建视图时需避免重复触发副作用（如发送邮件）。

专用系统：EventStoreDB、MartenDB、Axon Framework。

---

## 数据框与矩阵：科学计算的基石

数据框（Pandas、Spark）和多维数组（NumPy、TileDB）是数据分析和机器学习的核心工具。它们支持：
- 类 SQL 的批量操作（过滤、分组、聚合）；
- 数据透视与矩阵转换；
- 稀疏矩阵与独热编码（One-Hot Encoding）；
- 高效线性代数运算。

示例：将“用户-电影评分表”转为矩阵，用于推荐系统：

| 用户 \ 电影 | 喜剧 | 剧情 | 恐怖 |
|-------------|------|------|------|
| Alice       | 5    | 3    | 0    |
| Bob         | 0    | 4    | 5    |

---

## 总结与选型建议

- **关系模型**：适合结构化数据、复杂 JOIN、事务一致性要求高的场景（如金融、ERP）；
- **文档模型**：适合树状结构、读多写少、模式灵活的应用（如 CMS、配置管理）；
- **图模型**：适合高度互联数据、多跳查询（如社交网络、欺诈检测）；
- **事件溯源**：适合复杂业务流程、需要审计追溯的系统（如电商、医疗）；
- **数据框/矩阵**：适合统计分析、机器学习、科学计算。

> **没有银弹**：选择数据模型时，需综合考虑数据结构、查询模式、一致性要求、团队技能等因素。现代数据库正趋向“多模型融合”，如 PostgreSQL 支持 JSON + 图查询，MongoDB 支持 JOIN，让你在同一系统中灵活组合不同模型。

下一章，我们将深入探讨这些模型背后的**存储引擎实现原理**。